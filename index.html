\<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Audio Lab ‚Äî Pitch ‚Ä¢ Distortion/Bass ‚Ä¢ Comp ‚Ä¢ Trem ‚Ä¢ Widener ‚Ä¢ Bitcrusher ‚Ä¢ Analyzer</title>
<style>
  :root { --bg:#0b1220; --panel:#111a2b; --ink:#e8f0ff; --accent:#6aa1ff; --muted:#9bb3d7; --grid:rgba(255,255,255,.08); }
  * { box-sizing: border-box; font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif; }
  body { margin:0; background: radial-gradient(1200px 600px at 20% -10%, #152447, #0b1220); color:var(--ink); }
  header { padding:24px 20px 0; text-align:center; }
  header h1 { margin:0 0 6px; font-weight:800; letter-spacing:.2px; }
  header p { margin:0; color:var(--muted); }
  .wrap { max-width:1120px; margin:24px auto 60px; padding:0 16px; }
  .grid { display:grid; gap:16px; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
  .card { background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
          border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:16px;
          box-shadow: 0 10px 30px rgba(0,0,0,.3); }
  .row { display:flex; gap:10px; align-items:center; margin:10px 0; flex-wrap:wrap; }
  label { font-size:13px; color:var(--muted); min-width:160px; }
  input[type="range"], select, input[type="file"] { flex:1; }
  input[type="checkbox"] { transform: scale(1.15); }
  button { background:var(--accent); color:#071122; border:none; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; }
  button.ghost { background:transparent; border:1px solid rgba(255,255,255,.25); color:var(--ink); }
  .big { font-size:18px; padding:12px 18px; }
  .meter { font-variant-numeric: tabular-nums; color:var(--muted); min-width:90px; text-align:right; }
  .muted { color:var(--muted); font-size:12px; }
  .footer { text-align:center; color:var(--muted); margin-top:24px; font-size:13px; }
  .pill { display:inline-block; padding:4px 10px; border-radius:999px; background:rgba(255,255,255,.08); font-size:12px; color:var(--muted); }
  /* Analyzer canvases */
  .scopeCanvas { width:100%; height:160px; display:block; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)); border:1px solid rgba(255,255,255,.08); }
</style>
<!-- SoundTouch.js for offline pitch -->
<script src="https://cdn.jsdelivr.net/gh/corbanbrook/dsp.js/soundtouch.min.js"></script>
</head>
<body>
<header>
  <h1>Mini Audio Lab</h1>
  <p>Distortion ‚Ä¢ Bass ‚Ä¢ Filter ‚Ä¢ Delay ‚Ä¢ Reverb ‚Ä¢ Pitch (bounce) ‚Ä¢ Comp ‚Ä¢ Trem ‚Ä¢ Widener ‚Ä¢ Bitcrusher ‚Ä¢ <b>Analyzer</b> ‚Ä¢ Presets ‚Ä¢ Record ‚Ä¢ Bounce</p>
</header>

<div class="wrap">
  <div class="grid">

    <!-- 1) Load & Transport -->
    <div class="card">
      <h3>1) Load & Transport</h3>
      <div class="row"><input id="file" type="file" accept="audio/*" /></div>
      <div class="row">
        <button id="play" class="big">‚ñ∂Ô∏è Play</button>
        <button id="pause" class="ghost big">‚è∏Ô∏è Pause</button>
        <button id="stop" class="ghost big">‚èπÔ∏è Stop</button>
        <span id="time" class="meter">00:00 / 00:00</span>
      </div>
      <div class="row">
        <label>Output Gain (dB)</label>
        <input id="gain" type="range" min="-24" max="6" step="0.1" value="-3">
        <span class="meter" id="gainVal">-3.0 dB</span>
      </div>
      <div class="row">
        <label>Playback Rate (speed+pitch)</label>
        <input id="rate" type="range" min="0.5" max="2.0" step="0.01" value="1.00">
        <span class="meter" id="rateVal">1.00√ó</span>
      </div>
      <div class="muted">‚ö†Ô∏è This changes both speed & pitch. Use Pitch Shift for pitch-only.</div>
    </div>

    <!-- 2) Distortion -->
    <div class="card">
      <h3>2) Distortion</h3>
      <div class="row">
        <label>Drive</label>
        <input id="distDrive" type="range" min="0" max="1000" step="1" value="400">
        <span class="meter" id="distDriveVal">400</span>
      </div>
      <div class="row">
        <label>Tone (Hz low-pass)</label>
        <input id="distTone" type="range" min="500" max="12000" step="100" value="8000">
        <span class="meter" id="distToneVal">8000 Hz</span>
      </div>
    </div>

    <!-- 3) Bass Boost -->
    <div class="card">
      <h3>3) Bass Boost</h3>
      <div class="row">
        <label>Bass Gain (dB)</label>
        <input id="bassGain" type="range" min="-10" max="12" step="0.5" value="0">
        <span class="meter" id="bassGainVal">0 dB</span>
      </div>
    </div>

    <!-- 4) Filter -->
    <div class="card">
      <h3>4) Filter</h3>
      <div class="row">
        <label>Filter Type</label>
        <select id="filterType">
          <option value="lowpass">Lowpass</option>
          <option value="highpass">Highpass</option>
          <option value="bandpass">Bandpass</option>
          <option value="peaking">Peaking (EQ)</option>
          <option value="notch">Notch</option>
        </select>
      </div>
      <div class="row">
        <label>Cutoff / Freq (Hz)</label>
        <input id="filterFreq" type="range" min="50" max="12000" step="1" value="1200">
        <span class="meter" id="freqVal">1200 Hz</span>
      </div>
      <div class="row">
        <label>Q / Resonance</label>
        <input id="filterQ" type="range" min="0.1" max="20" step="0.1" value="1.0">
        <span class="meter" id="qVal">1.0</span>
      </div>
      <div class="row">
        <label>Filter Gain (peaking)</label>
        <input id="filterGain" type="range" min="-24" max="24" step="0.1" value="0">
        <span class="meter" id="fGainVal">0.0 dB</span>
      </div>
      <div class="row">
        <label>Wet / Dry Mix</label>
        <input id="filterWet" type="range" min="0" max="1" step="0.01" value="0.6">
        <span class="meter" id="fWetVal">0.60</span>
      </div>
    </div>

    <!-- 5) Delay -->
    <div class="card">
      <h3>5) Delay</h3>
      <div class="row">
        <label>Delay Time (s)</label>
        <input id="delayTime" type="range" min="0" max="1.0" step="0.005" value="0.25">
        <span class="meter" id="dTimeVal">0.250 s</span>
      </div>
      <div class="row">
        <label>Feedback</label>
        <input id="delayFb" type="range" min="0" max="0.95" step="0.01" value="0.35">
        <span class="meter" id="dFbVal">0.35</span>
      </div>
      <div class="row">
        <label>Wet / Dry Mix</label>
        <input id="delayWet" type="range" min="0" max="1" step="0.01" value="0.35">
        <span class="meter" id="dWetVal">0.35</span>
      </div>
    </div>

    <!-- 6) Reverb -->
    <div class="card">
      <h3>6) Reverb</h3>
      <div class="row">
        <label>Reverb Wet / Dry</label>
        <input id="reverbWet" type="range" min="0" max="1" step="0.01" value="0.25">
        <span class="meter" id="rWetVal">0.25</span>
      </div>
      <div class="muted">Impulse response generated procedurally.</div>
    </div>

    <!-- 7) Pitch Shift -->
    <div class="card">
      <h3>7) Pitch Shift</h3>
      <div class="row">
        <label>Shift (semitones)</label>
        <input id="pitchShift" type="range" min="-12" max="12" step="1" value="0">
        <span class="meter" id="pShiftVal">0 st</span>
      </div>
      <div class="muted">Uses SoundTouch.js in offline bounce ‚úÖ</div>
    </div>

    <!-- 8) Compressor -->
    <div class="card">
      <h3>8) Compressor</h3>
      <div class="row">
        <label>Threshold (dB)</label>
        <input id="compThresh" type="range" min="-100" max="0" step="1" value="-24">
        <span class="meter" id="compThreshVal">-24 dB</span>
      </div>
      <div class="row">
        <label>Knee (dB)</label>
        <input id="compKnee" type="range" min="0" max="40" step="1" value="30">
        <span class="meter" id="compKneeVal">30 dB</span>
      </div>
      <div class="row">
        <label>Ratio</label>
        <input id="compRatio" type="range" min="1" max="20" step="0.1" value="4">
        <span class="meter" id="compRatioVal">4:1</span>
      </div>
      <div class="row">
        <label>Attack (ms)</label>
        <input id="compAttack" type="range" min="0" max="1000" step="1" value="10">
        <span class="meter" id="compAttackVal">10 ms</span>
      </div>
      <div class="row">
        <label>Release (ms)</label>
        <input id="compRelease" type="range" min="10" max="2000" step="10" value="250">
        <span class="meter" id="compReleaseVal">250 ms</span>
      </div>
      <div class="row">
        <label>Makeup Gain (dB)</label>
        <input id="compMakeup" type="range" min="-24" max="24" step="0.1" value="0">
        <span class="meter" id="compMakeupVal">0.0 dB</span>
      </div>
      <div class="muted">DynamicsCompressor on the full mix + makeup gain after compression.</div>
    </div>

    <!-- 9) Tremolo -->
    <div class="card">
      <h3>9) Tremolo</h3>
      <div class="row">
        <label>Enable Tremolo</label>
        <input id="tremOn" type="checkbox" />
        <span class="muted">Amplitude modulation</span>
      </div>
      <div class="row">
        <label>Rate (Hz)</label>
        <input id="tremRate" type="range" min="0.10" max="20" step="0.01" value="5">
        <span class="meter" id="tremRateVal">5.00 Hz</span>
      </div>
      <div class="row">
        <label>Depth</label>
        <input id="tremDepth" type="range" min="0" max="1" step="0.01" value="0.5">
        <span class="meter" id="tremDepthVal">0.50</span>
      </div>
      <div class="muted">Depth uses DC offset so max stays at unity (no surprise boosts).</div>
    </div>

    <!-- 10) Stereo Widener -->
    <div class="card">
      <h3>10) Stereo Widener</h3>
      <div class="row">
        <label>Width (0‚Äì200%)</label>
        <input id="wideWidth" type="range" min="0" max="2" step="0.01" value="1">
        <span class="meter" id="wideWidthVal">100 %</span>
      </div>
      <div class="row">
        <label>Haas Delay Right (ms)</label>
        <input id="wideHaas" type="range" min="0" max="25" step="0.1" value="0">
        <span class="meter" id="wideHaasVal">0.0 ms</span>
      </div>
      <div class="muted">Mid/Side width scaler + optional micro-delay on the right channel.</div>
    </div>

    <!-- 11) Bitcrusher -->
    <div class="card">
      <h3>11) Bitcrusher</h3>
      <div class="row">
        <label>Bits</label>
        <input id="crushBits" type="range" min="4" max="16" step="1" value="12">
        <span class="meter" id="crushBitsVal">12-bit</span>
      </div>
      <div class="row">
        <label>Mix (Wet/Dry)</label>
        <input id="crushMix" type="range" min="0" max="1" step="0.01" value="0">
        <span class="meter" id="crushMixVal">0.00</span>
      </div>
      <div class="muted">WaveShaper bit-depth reduction (offline + live). 0 = bypass.</div>
    </div>

    <!-- 12) Analyzer -->
    <div class="card">
      <h3>12) Analyzer</h3>
      <div class="row">
        <label>Tap</label>
        <select id="anTap">
          <option value="post">Post-Master (final)</option>
          <option value="pre">Pre-FX (pitch out)</option>
        </select>
        <label>FFT</label>
        <select id="anFFT">
          <option>512</option><option>1024</option><option selected>2048</option><option>4096</option><option>8192</option>
        </select>
        <label>Smoothing</label>
        <input id="anSmooth" type="range" min="0" max="0.95" step="0.01" value="0.7">
        <span class="meter" id="anSmoothVal">0.70</span>
      </div>
      <div class="row">
        <label>Waveform</label>
        <canvas id="waveCanvas" class="scopeCanvas"></canvas>
      </div>
      <div class="row">
        <label>Spectrum</label>
        <canvas id="fftCanvas" class="scopeCanvas"></canvas>
      </div>
      <div class="muted">Switch tap to hear/see how FX shape the signal. FFT shows magnitude (dBFS-ish).</div>
    </div>

    <!-- 13) Presets -->
    <div class="card">
      <h3>13) Presets</h3>
      <div class="row">
        <input id="presetName" type="text" placeholder="Preset name‚Ä¶" />
        <button id="savePreset" class="big">üíæ Save</button>
      </div>
      <div class="row">
        <select id="presetList"></select>
        <button id="loadPreset" class="ghost big">üìÇ Load</button>
        <button id="deletePreset" class="ghost big">‚ùå Delete</button>
      </div>
      <div class="muted">Presets are saved in your browser‚Äôs localStorage.</div>
    </div>

    <!-- 14) Download -->
    <div class="card">
      <h3>14) Download</h3>
      <div class="row">
        <button id="recStart" class="big">‚è∫Ô∏è Start Recording (WebM)</button>
        <button id="recStop" class="ghost big" disabled>‚èπÔ∏è Stop</button>
        <span id="recStatus" class="pill">idle</span>
      </div>
      <div class="row">
        <button id="bounce" class="big">üìÄ Bounce to WAV</button>
        <span id="bounceStatus" class="pill">ready</span>
      </div>
      <div class="row">
        <a id="saveLast" class="big" href="#" download="output.wav">üíæ Download Last File</a>
      </div>
      <div class="muted">Recording = live tweaks (.webm). Bounce = full render (.wav).</div>
    </div>

  </div>
  <div class="footer">If playback fails, click Play again‚Äîbrowser wants a gesture to start audio.</div>
</div>

<script>
(() => {
  const $=id=>document.getElementById(id);

  // UI elements
  const fileEl=$("file"), playBtn=$("play"), pauseBtn=$("pause"), stopBtn=$("stop");
  const timeEl=$("time"), gainEl=$("gain"), gainVal=$("gainVal"), rateEl=$("rate"), rateVal=$("rateVal");
  const distDrive=$("distDrive"), distDriveVal=$("distDriveVal");
  const distTone=$("distTone"), distToneVal=$("distToneVal");
  const bassGain=$("bassGain"), bassGainVal=$("bassGainVal");
  const filterType=$("filterType"), filterFreq=$("filterFreq"), freqVal=$("freqVal");
  const filterQ=$("filterQ"), qVal=$("qVal"), filterGain=$("filterGain"), fGainVal=$("fGainVal");
  const filterWet=$("filterWet"), fWetVal=$("fWetVal");
  const delayTime=$("delayTime"), dTimeVal=$("dTimeVal"), delayFb=$("delayFb"), dFbVal=$("dFbVal");
  const delayWet=$("delayWet"), dWetVal=$("dWetVal");
  const reverbWet=$("reverbWet"), rWetVal=$("rWetVal");
  const pitchShift=$("pitchShift"), pShiftVal=$("pShiftVal");

  // Compressor
  const compThresh=$("compThresh"), compThreshVal=$("compThreshVal");
  const compKnee=$("compKnee"), compKneeVal=$("compKneeVal");
  const compRatio=$("compRatio"), compRatioVal=$("compRatioVal");
  const compAttack=$("compAttack"), compAttackVal=$("compAttackVal");
  const compRelease=$("compRelease"), compReleaseVal=$("compReleaseVal");
  const compMakeup=$("compMakeup"), compMakeupVal=$("compMakeupVal");

  // Tremolo
  const tremOn=$("tremOn"), tremRate=$("tremRate"), tremRateVal=$("tremRateVal");
  const tremDepth=$("tremDepth"), tremDepthVal=$("tremDepthVal");

  // Widener
  const wideWidth=$("wideWidth"), wideWidthVal=$("wideWidthVal");
  const wideHaas=$("wideHaas"), wideHaasVal=$("wideHaasVal");

  // Bitcrusher
  const crushBits=$("crushBits"), crushBitsVal=$("crushBitsVal");
  const crushMix=$("crushMix"), crushMixVal=$("crushMixVal");

  // Analyzer UI
  const anTap=$("anTap"), anFFT=$("anFFT"), anSmooth=$("anSmooth"), anSmoothVal=$("anSmoothVal");
  const waveCanvas=$("waveCanvas"), fftCanvas=$("fftCanvas");

  // Presets & Download
  const presetName=$("presetName"), savePreset=$("savePreset");
  const presetList=$("presetList"), loadPreset=$("loadPreset"), deletePreset=$("deletePreset");
  const recStart=$("recStart"), recStop=$("recStop"), recStatus=$("recStatus");
  const bounceBtn=$("bounce"), bounceStatus=$("bounceStatus");
  const saveLast=$("saveLast");

  // AudioContext
  const ctx=new (window.AudioContext||window.webkitAudioContext)();
  let audioBuf=null, source=null, startTime=0, pauseOffset=0, duration=0;

  // Final master
  const master=ctx.createGain(); master.connect(ctx.destination);

  // ===== Front FX: Pitch -> Distortion -> Tone -> Bass =====
  function makeDistortionCurve(amount=400){
    const n=44100, curve=new Float32Array(n);
    const deg=Math.PI/180;
    for(let i=0;i<n;i++){
      const x=i*2/n-1;
      curve[i]=(3+amount)*x*20*deg/(Math.PI+amount*Math.abs(x));
    }
    return curve;
  }
  const waveShaper=ctx.createWaveShaper();
  waveShaper.curve=makeDistortionCurve(400);
  waveShaper.oversample="4x";
  const distToneFilter=ctx.createBiquadFilter();
  distToneFilter.type="lowpass"; distToneFilter.frequency.value=8000;
  waveShaper.connect(distToneFilter);

  const bass=ctx.createBiquadFilter(); // low-shelf
  bass.type="lowshelf"; bass.frequency.value=100; bass.gain.value=0;
  distToneFilter.connect(bass);

  // ===== Parallel sends (post-bass) =====
  const dry=ctx.createGain(); bass.connect(dry);
  const biquad=ctx.createBiquadFilter();
  const filterOut=ctx.createGain(); biquad.connect(filterOut);
  const delay=ctx.createDelay(2.0);
  const dWet=ctx.createGain(); const dFb=ctx.createGain(); delay.connect(dWet); delay.connect(dFb); dFb.connect(delay);
  const convolver=ctx.createConvolver();
  const rWet=ctx.createGain(); convolver.connect(rWet);

  // Feed post-bass into wet sends
  bass.connect(biquad);
  bass.connect(delay);
  bass.connect(convolver);

  // ===== Mix bus =====
  const mix=ctx.createGain();
  dry.connect(mix); filterOut.connect(mix); dWet.connect(mix); rWet.connect(mix);

  // ===== Compressor + makeup =====
  const comp=ctx.createDynamicsCompressor();
  comp.threshold.value=-24; comp.knee.value=30; comp.ratio.value=4; comp.attack.value=0.010; comp.release.value=0.250;
  const compMakeupGain=ctx.createGain(); compMakeupGain.gain.value=1.0;

  // ===== Tremolo VCA =====
  const tremVCA=ctx.createGain(); tremVCA.gain.value=1.0;
  const tremDC=ctx.createConstantSource(); tremDC.offset.value=1;
  const lfo=ctx.createOscillator(); lfo.type="sine"; lfo.frequency.value=5;
  const lfoGain=ctx.createGain(); lfoGain.gain.value=0;
  lfo.connect(lfoGain); lfoGain.connect(tremVCA.gain); tremDC.connect(tremVCA.gain);

  // ===== Bitcrusher (WaveShaper) with wet/dry mix =====
  function crushCurve(bits){
    const levels=Math.pow(2, bits)-1;
    const n=65536; const curve=new Float32Array(n);
    for(let i=0;i<n;i++){
      const x=i/(n-1)*2-1;
      curve[i]= (Math.round((x+1)/2*levels)/levels*2-1);
    }
    return curve;
  }
  const crushWS=ctx.createWaveShaper(); crushWS.curve=crushCurve(12);
  const crushDry=ctx.createGain(); crushDry.gain.value=1.0;
  const crushWet=ctx.createGain(); crushWet.gain.value=0.0;
  const crushSum=ctx.createGain();

  // ===== Stereo Widener (Mid/Side + optional Haas on Right) =====
  const splitter=ctx.createChannelSplitter(2);
  const merger=ctx.createChannelMerger(2);

  // M/S matrix
  const K=1/Math.sqrt(2);
  const lToM=ctx.createGain(); lToM.gain.value=K;
  const rToM=ctx.createGain(); rToM.gain.value=K;
  const lToS=ctx.createGain(); lToS.gain.value=K;
  const rToS=ctx.createGain(); rToS.gain.value=-K;
  const mBus=ctx.createGain();
  const sBus=ctx.createGain(); sBus.gain.value=1.0;

  const mToL=ctx.createGain(); mToL.gain.value=1.0;
  const sToL=ctx.createGain(); sToL.gain.value=1.0;
  const mToR=ctx.createGain(); mToR.gain.value=1.0;
  const sInv=ctx.createGain(); sInv.gain.value=-1.0;
  const haasR=ctx.createDelay(0.050); haasR.delayTime.value=0.0;

  // ===== Pitch shifter (granular, live only) =====
  class PitchShifter {
    constructor(ctx){
      this.ctx=ctx;
      this.input=ctx.createGain();
      this.output=ctx.createGain();
      this.pitch=0; // ratio
      this.bufferSize=1024;
      this.proc=ctx.createScriptProcessor(this.bufferSize,1,1);
      this.proc.onaudioprocess=e=>this.process(e);
      this.input.connect(this.proc);
      this.proc.connect(this.output);
      this.buf=new Float32Array(this.bufferSize*2);
      this.bufIndex=0;
    }
    setPitch(semi){ this.pitch=Math.pow(2,semi/12); }
    process(e){
      const input=e.inputBuffer.getChannelData(0);
      const output=e.outputBuffer.getChannelData(0);
      for(let i=0;i<input.length;i++){
        this.buf[this.bufIndex]=input[i];
        this.bufIndex=(this.bufIndex+1)%this.buf.length;
        output[i]=this.buf[(Math.floor(this.bufIndex*this.pitch))%this.buf.length]||0;
      }
    }
  }
  const shifter=new PitchShifter(ctx);
  shifter.output.connect(waveShaper);

  // === Wire the main chain ===
  mix.connect(comp);
  comp.connect(compMakeupGain);
  compMakeupGain.connect(tremVCA);

  // tremVCA -> bitcrusher wet/dry
  tremVCA.connect(crushDry);
  tremVCA.connect(crushWS);
  crushWS.connect(crushWet);
  crushDry.connect(crushSum);
  crushWet.connect(crushSum);

  // crushSum (stereo) -> widener M/S matrix -> master
  crushSum.connect(splitter);
  // L/R into M/S
  splitter.connect(lToM,0); lToM.connect(mBus);
  splitter.connect(rToM,1); rToM.connect(mBus);
  splitter.connect(lToS,0); lToS.connect(sBus);
  splitter.connect(rToS,1); rToS.connect(sBus);
  // M/S back to L/R
  mBus.connect(mToL);  mToL.connect(merger,0,0);
  sBus.connect(sToL);  sToL.connect(merger,0,0);
  mBus.connect(mToR);  mToR.connect(haasR); haasR.connect(merger,0,1);
  sBus.connect(sInv);  sInv.connect(haasR);

  // Analyzer taps
  const analyserPre=ctx.createAnalyser();
  const analyserPost=ctx.createAnalyser();
  analyserPre.fftSize=2048; analyserPost.fftSize=2048;
  analyserPre.smoothingTimeConstant=0.7; analyserPost.smoothingTimeConstant=0.7;
  // Pre-FX: tap the shifter output (before any processing)
  shifter.output.connect(analyserPre);
  // Post-Master: insert a postTap so we can visualize final audio
  const postTap=ctx.createGain(); // unity
  merger.connect(postTap); postTap.connect(master); postTap.connect(analyserPost);

  // Helpers
  function dbToGain(db){return Math.pow(10,db/20);}
  function connectSource(node){ node.connect(shifter.input); }
  function createSource(){
    if(!audioBuf) return null;
    const s=ctx.createBufferSource();
    s.buffer=audioBuf;
    s.playbackRate.value=parseFloat(rateEl.value);
    connectSource(s);
    return s;
  }
  async function ensureRunning(){ if(ctx.state!=="running") await ctx.resume(); }
  let lastURL=null;
  function setDownload(blob,name){
    if(lastURL) URL.revokeObjectURL(lastURL);
    lastURL=URL.createObjectURL(blob);
    saveLast.href=lastURL; saveLast.download=name;
  }
  function fmt(sec){ if(!isFinite(sec)) return "00:00"; const m=Math.floor(sec/60),s=Math.floor(sec%60); return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`; }
  function updateTime(){
    let pos=pauseOffset;
    if(source && startTime>0){ const rate=parseFloat(rateEl.value); pos=pauseOffset+(ctx.currentTime-startTime)*rate; }
    pos=Math.max(0,Math.min(duration||0,pos));
    timeEl.textContent=`${fmt(pos)} / ${fmt(duration)}`;
    requestAnimationFrame(updateTime);
  }
  updateTime();

  // Reverb IR
  function buildImpulse(seconds=2, decay=2){
    const rate=ctx.sampleRate, len=Math.floor(rate*seconds);
    const buf=ctx.createBuffer(2,len,rate);
    for(let c=0;c<2;c++){
      const chan=buf.getChannelData(c);
      for(let i=0;i<len;i++){ chan[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay); }
    }
    return buf;
  }
  convolver.buffer=buildImpulse();

  // Start LFO/DC (harmless until trem enabled)
  lfo.start(); tremDC.start();

  // File load
  fileEl.onchange=async e=>{
    const f=e.target.files?.[0];
    if(!f) return;
    const arr=await f.arrayBuffer();
    audioBuf=await ctx.decodeAudioData(arr);
    duration=audioBuf.duration;
    pauseOffset=0;
  };

  // Transport
  playBtn.onclick=async()=>{
    if(!audioBuf) return;
    await ensureRunning();
    if(source) return;
    source=createSource();
    startTime=ctx.currentTime;
    source.onended=()=>{source=null; startTime=0; pauseOffset=0;};
    source.start(0,pauseOffset);
  };
  pauseBtn.onclick=()=>{
    if(!source) return;
    pauseOffset+=ctx.currentTime-startTime;
    try{source.stop();}catch{}
    source=null; startTime=0;
  };
  stopBtn.onclick=()=>{
    if(source){ try{source.stop();}catch{} }
    source=null; startTime=0; pauseOffset=0;
  };

  // UI bindings
  gainEl.oninput=e=>{const db=+e.target.value; master.gain.value=dbToGain(db); gainVal.textContent=db.toFixed(1)+" dB";};
  rateEl.oninput=e=>{const r=+e.target.value; rateVal.textContent=r.toFixed(2)+"√ó"; if(source) source.playbackRate.value=r;};

  distDrive.oninput=e=>{const v=+e.target.value; waveShaper.curve=makeDistortionCurve(v); distDriveVal.textContent=v;};
  distTone.oninput=e=>{const v=+e.target.value; distToneFilter.frequency.value=v; distToneVal.textContent=v+" Hz";};
  bassGain.oninput=e=>{const v=+e.target.value; bass.gain.value=v; bassGainVal.textContent=v+" dB";};

  filterType.onchange=e=>biquad.type=e.target.value;
  filterFreq.oninput=e=>{const v=+e.target.value; biquad.frequency.value=v; freqVal.textContent=v+" Hz";};
  filterQ.oninput=e=>{const v=+e.target.value; biquad.Q.value=v; qVal.textContent=v;};
  filterGain.oninput=e=>{const v=+e.target.value; biquad.gain.value=v; fGainVal.textContent=v+" dB";};
  filterWet.oninput=e=>{const v=+e.target.value; filterOut.gain.value=v; fWetVal.textContent=v;};

  delayTime.oninput=e=>{const v=+e.target.value; delay.delayTime.value=v; dTimeVal.textContent=v+" s";};
  delayFb.oninput=e=>{const v=+e.target.value; dFb.gain.value=v; dFbVal.textContent=v;};
  delayWet.oninput=e=>{const v=+e.target.value; dWet.gain.value=v; dWetVal.textContent=v;};

  reverbWet.oninput=e=>{const v=+e.target.value; rWet.gain.value=v; rWetVal.textContent=v;};

  pitchShift.oninput=e=>{const semi=parseInt(e.target.value); pShiftVal.textContent=semi+" st"; shifter.setPitch(semi);};

  // Compressor bindings
  compThresh.oninput=e=>{const v=+e.target.value; comp.threshold.value=v; compThreshVal.textContent=v+" dB";};
  compKnee.oninput=e=>{const v=+e.target.value; comp.knee.value=v; compKneeVal.textContent=v+" dB";};
  compRatio.oninput=e=>{const v=+e.target.value; comp.ratio.value=v; compRatioVal.textContent=v.toFixed(1)+":1";};
  compAttack.oninput=e=>{const v=+e.target.value; comp.attack.value=v/1000; compAttackVal.textContent=v+" ms";};
  compRelease.oninput=e=>{const v=+e.target.value; comp.release.value=v/1000; compReleaseVal.textContent=v+" ms";};
  compMakeup.oninput=e=>{const v=+e.target.value; compMakeupGain.gain.value=dbToGain(v); compMakeupVal.textContent=v.toFixed(1)+" dB";};

  // Tremolo
  function applyTremoloParams(){
    const rate=+tremRate.value, depth=+tremDepth.value, on=tremOn.checked;
    lfo.frequency.value=rate;
    lfoGain.gain.value=(on? depth/2 : 0);
    tremDC.offset.value=(on? 1 - depth/2 : 1);
    tremRateVal.textContent=rate.toFixed(2)+" Hz";
    tremDepthVal.textContent=depth.toFixed(2);
  }
  tremOn.onchange=applyTremoloParams;
  tremRate.oninput=applyTremoloParams;
  tremDepth.oninput=applyTremoloParams;
  applyTremoloParams();

  // Bitcrusher UI
  function applyCrushParams(){
    const bits=parseInt(crushBits.value);
    const mix=+crushMix.value;
    crushWS.curve=crushCurve(bits);
    crushDry.gain.value=1-mix;
    crushWet.gain.value=mix;
    crushBitsVal.textContent=bits+"-bit";
    crushMixVal.textContent=mix.toFixed(2);
  }
  crushBits.oninput=applyCrushParams;
  crushMix.oninput=applyCrushParams;
  applyCrushParams();

  // Widener UI
  function applyWidthParams(){
    const w=+wideWidth.value; // 0..2
    const ms=+wideHaas.value; // 0..25
    sBus.gain.value=w;
    haasR.delayTime.value=ms/1000;
    wideWidthVal.textContent=(w*100).toFixed(0)+" %";
    wideHaasVal.textContent=ms.toFixed(1)+" ms";
  }
  wideWidth.oninput=applyWidthParams;
  wideHaas.oninput=applyWidthParams;
  applyWidthParams();

  // Recording (captures master)
  let mediaRecorder=null, recChunks=[];
  recStart.onclick=async()=>{
    await ensureRunning();
    if(!audioBuf) return alert("Load an audio file first.");
    const recDest=ctx.createMediaStreamDestination();
    master.connect(recDest);  // capture full processed mix
    mediaRecorder=new MediaRecorder(recDest.stream);
    recChunks=[];
    mediaRecorder.ondataavailable=e=>{if(e.data.size) recChunks.push(e.data);};
    mediaRecorder.onstop=()=>{
      const blob=new Blob(recChunks,{type:"audio/webm"});
      const ts=new Date().toISOString().replace(/[:.]/g,"-");
      setDownload(blob,"MiniAudioLab-"+ts+".webm");
      recStatus.textContent="saved";
    };
    mediaRecorder.start();
    recStatus.textContent="recording‚Ä¶";
    recStart.disabled=true; recStop.disabled=false;
  };
  recStop.onclick=()=>{
    if(mediaRecorder&&mediaRecorder.state==="recording"){
      mediaRecorder.stop();
      recStatus.textContent="finalizing‚Ä¶";
      recStart.disabled=false; recStop.disabled=true;
    }
  };

  // ===== SoundTouch offline pitch helper =====
  async function applyOfflinePitchWithSoundTouch(srcBuf, semitones){
    try{
      if(!window.soundtouch || !window.soundtouch.SoundTouch){
        console.warn("SoundTouch.js not available; skipping offline pitch.");
        return null;
      }
      const st=new window.soundtouch.SoundTouch(srcBuf.sampleRate);
      const ratio=Math.pow(2,semitones/12);
      st.pitch=ratio; st.tempo=1.0; st.rate=1.0;

      const BufferSource=window.soundtouch.BufferSource;
      const SimpleFilter=window.soundtouch.SimpleFilter;
      if(!BufferSource||!SimpleFilter){ console.warn("SoundTouch helpers missing; skipping offline pitch."); return null; }

      const src=new BufferSource(srcBuf);
      const filter=new SimpleFilter(src,st);

      const BLOCK=16384;
      const L=[], R=[];
      let done=false;
      while(!done){
        const outL=new Float32Array(BLOCK);
        const outR=new Float32Array(BLOCK);
        let frames=0;
        if(typeof filter.extractStereo==="function"){
          frames=filter.extractStereo(outL,outR,BLOCK);
        }else if(typeof filter.extract==="function"){
          frames=filter.extract(outL,BLOCK);
          outR.set(outL);
        }else{
          console.warn("SoundTouch filter has no extract method; skipping offline pitch.");
          return null;
        }
        if(frames>0){
          L.push(outL.subarray(0,frames));
          R.push(outR.subarray(0,frames));
        }else{
          done=true;
        }
      }
      const total=L.reduce((n,a)=>n+a.length,0);
      const left=new Float32Array(total), right=new Float32Array(total);
      let off=0;
      for(let i=0;i<L.length;i++){ left.set(L[i],off); right.set(R[i],off); off+=L[i].length; }

      const out=new AudioBuffer({numberOfChannels:2,length:total,sampleRate:srcBuf.sampleRate});
      out.copyToChannel(left,0); out.copyToChannel(right,1);
      return out;
    }catch(err){
      console.warn("SoundTouch offline pitch failed; skipping. Error:",err);
      return null;
    }
  }

  // ===== Bounce (offline render with all FX) =====
  bounceBtn.onclick=async()=>{
    if(!audioBuf) return alert("Load an audio file first.");
    bounceStatus.textContent="bouncing‚Ä¶";

    const settings={
      rate:+rateEl.value, gain:+gainEl.value,
      dist:{drive:+distDrive.value, tone:+distTone.value},
      bass:{gain:+bassGain.value},
      filter:{type:filterType.value, freq:+filterFreq.value, Q:+filterQ.value, gain:+filterGain.value, wet:+filterWet.value},
      delay:{time:+delayTime.value, fb:+delayFb.value, wet:+delayWet.value},
      reverb:{wet:+reverbWet.value},
      pitch:parseInt(pitchShift.value),
      comp:{thresh:+compThresh.value, knee:+compKnee.value, ratio:+compRatio.value, attack:+compAttack.value/1000, release:+compRelease.value/1000, makeup:+compMakeup.value},
      trem:{on:tremOn.checked, rate:+tremRate.value, depth:+tremDepth.value},
      widen:{width:+wideWidth.value, haasMs:+wideHaas.value},
      crush:{bits:parseInt(crushBits.value), mix:+crushMix.value}
    };

    // Optional offline pitch
    let pitched=audioBuf;
    if(settings.pitch!==0){
      const p=await applyOfflinePitchWithSoundTouch(audioBuf, settings.pitch);
      if(p) pitched=p; else console.warn("Proceeding without offline pitch.");
    }

    const srcDur=pitched.duration/settings.rate;
    const tail=5.0;
    const off=new OfflineAudioContext(2,Math.ceil((srcDur+tail)*ctx.sampleRate),ctx.sampleRate);

    const src=off.createBufferSource();
    src.buffer=pitched; src.playbackRate.value=settings.rate;

    const master=off.createGain(); master.gain.value=dbToGain(settings.gain); master.connect(off.destination);

    // Front FX: distortion -> tone -> bass
    function makeCurve(amount=400){
      const n=44100, curve=new Float32Array(n);
      const deg=Math.PI/180;
      for(let i=0;i<n;i++){ const x=i*2/n-1; curve[i]=(3+amount)*x*20*deg/(Math.PI+amount*Math.abs(x)); }
      return curve;
    }
    const ws=off.createWaveShaper(); ws.curve=makeCurve(settings.dist.drive); ws.oversample="4x";
    const tone=off.createBiquadFilter(); tone.type="lowpass"; tone.frequency.value=settings.dist.tone; ws.connect(tone);
    const bass=off.createBiquadFilter(); bass.type="lowshelf"; bass.frequency.value=100; bass.gain.value=settings.bass.gain; tone.connect(bass);

    // Sends
    const dry=off.createGain(); bass.connect(dry);
    const biquad=off.createBiquadFilter();
    biquad.type=settings.filter.type; biquad.frequency.value=settings.filter.freq; biquad.Q.value=settings.filter.Q; biquad.gain.value=settings.filter.gain;
    const fOut=off.createGain(); fOut.gain.value=settings.filter.wet; biquad.connect(fOut);
    const delay=off.createDelay(2.0); delay.delayTime.value=settings.delay.time;
    const dWet=off.createGain(); dWet.gain.value=settings.delay.wet;
    const dFb=off.createGain(); dFb.gain.value=settings.delay.fb; delay.connect(dFb); dFb.connect(delay);
    const convolver=off.createConvolver();
    (function(){
      const rate=off.sampleRate, len=Math.floor(rate*2);
      const buf=off.createBuffer(2,len,rate);
      for(let c=0;c<2;c++){ const ch=buf.getChannelData(c); for(let i=0;i<len;i++){ ch[i]=(Math.random()*2-1)*Math.pow(1-i/len,2); } }
      convolver.buffer=buf;
    })();
    const rWet=off.createGain(); rWet.gain.value=settings.reverb.wet; convolver.connect(rWet);

    // Feed into sends
    bass.connect(biquad);
    bass.connect(delay);
    bass.connect(convolver);

    // Mix bus
    const mix=off.createGain();
    dry.connect(mix); fOut.connect(mix); dWet.connect(mix); rWet.connect(mix);

    // Compressor + makeup
    const comp=off.createDynamicsCompressor();
    comp.threshold.value=settings.comp.thresh;
    comp.knee.value=settings.comp.knee;
    comp.ratio.value=settings.comp.ratio;
    comp.attack.value=settings.comp.attack;
    comp.release.value=settings.comp.release;
    const compMakeupGain=off.createGain(); compMakeupGain.gain.value=dbToGain(settings.comp.makeup);

    // Tremolo
    const tremVCA=off.createGain(); tremVCA.gain.value=1.0;
    const lfo=off.createOscillator(); lfo.type="sine"; lfo.frequency.value=settings.trem.rate;
    const lfoGain=off.createGain(); lfoGain.gain.value=(settings.trem.on? settings.trem.depth/2 : 0);
    const tremDC=off.createConstantSource(); tremDC.offset.value=(settings.trem.on? 1 - settings.trem.depth/2 : 1);

    // Bitcrusher
    function crushCurve(bits){
      const levels=Math.pow(2,bits)-1; const n=65536; const curve=new Float32Array(n);
      for(let i=0;i<n;i++){ const x=i/(n-1)*2-1; curve[i]= (Math.round((x+1)/2*levels)/levels*2-1); }
      return curve;
    }
    const crushWS=off.createWaveShaper(); crushWS.curve=crushCurve(settings.crush.bits);
    const crushDry=off.createGain(); crushDry.gain.value=1-settings.crush.mix;
    const crushWet=off.createGain(); crushWet.gain.value=settings.crush.mix;
    const crushSum=off.createGain();

    // Widener M/S + Haas Right
    const splitter=off.createChannelSplitter(2);
    const merger=off.createChannelMerger(2);
    const K=1/Math.sqrt(2);
    const lToM=off.createGain(); lToM.gain.value=K;
    const rToM=off.createGain(); rToM.gain.value=K;
    const lToS=off.createGain(); lToS.gain.value=K;
    const rToS=off.createGain(); rToS.gain.value=-K;
    const mBus=off.createGain();
    const sBus=off.createGain(); sBus.gain.value=settings.widen.width;
    const mToL=off.createGain(); mToL.gain.value=1.0;
    const sToL=off.createGain(); sToL.gain.value=1.0;
    const mToR=off.createGain(); mToR.gain.value=1.0;
    const sInv=off.createGain(); sInv.gain.value=-1.0;
    const haasR=off.createDelay(0.050); haasR.delayTime.value=settings.widen.haasMs/1000;

    // Wire the offline chain
    src.connect(ws); src.connect(biquad); src.connect(delay); src.connect(convolver);
    ws.connect(tone); tone.connect(bass);
    delay.connect(dWet);

    const mixBus=off.createGain();
    dry.connect(mixBus); fOut.connect(mixBus); dWet.connect(mixBus); rWet.connect(mixBus);

    mixBus.connect(comp); comp.connect(compMakeupGain); compMakeupGain.connect(tremVCA);

    // Trem
    lfo.connect(lfoGain); lfoGain.connect(tremVCA.gain); tremDC.connect(tremVCA.gain);
    lfo.start(0); tremDC.start(0);

    // Bitcrusher wet/dry
    tremVCA.connect(crushDry);
    tremVCA.connect(crushWS); crushWS.connect(crushWet);
    crushDry.connect(crushSum); crushWet.connect(crushSum);

    // Widener after crusher
    crushSum.connect(splitter);
    splitter.connect(lToM,0); lToM.connect(mBus);
    splitter.connect(rToM,1); rToM.connect(mBus);
    splitter.connect(lToS,0); lToS.connect(sBus);
    splitter.connect(rToS,1); rToS.connect(sBus);
    mBus.connect(mToL);  mToL.connect(merger,0,0);
    sBus.connect(sToL);  sToL.connect(merger,0,0);
    mBus.connect(mToR);  mToR.connect(haasR); haasR.connect(merger,0,1);
    sBus.connect(sInv);  sInv.connect(haasR);

    merger.connect(master);

    // Start and render
    src.start(0);
    const rendered=await off.startRendering();
    const wav=encodeWav(rendered);
    const ts=new Date().toISOString().replace(/[:.]/g,"-");
    setDownload(wav,"MiniAudioLab-Bounce-"+ts+".wav");
    bounceStatus.textContent="done";
  };

  // Presets
  function getState(){ return {
    gain:+gainEl.value, rate:+rateEl.value,
    distDrive:+distDrive.value, distTone:+distTone.value,
    bassGain:+bassGain.value,
    filterType:filterType.value, filterFreq:+filterFreq.value, filterQ:+filterQ.value, filterGain:+filterGain.value, filterWet:+filterWet.value,
    delayTime:+delayTime.value, delayFb:+delayFb.value, delayWet:+delayWet.value,
    reverbWet:+reverbWet.value, pitch:+pitchShift.value,
    compThresh:+compThresh.value, compKnee:+compKnee.value, compRatio:+compRatio.value, compAttack:+compAttack.value, compRelease:+compRelease.value, compMakeup:+compMakeup.value,
    tremOn:tremOn.checked, tremRate:+tremRate.value, tremDepth:+tremDepth.value,
    wideWidth:+wideWidth.value, wideHaas:+wideHaas.value,
    crushBits:+crushBits.value, crushMix:+crushMix.value,
    anTap:anTap.value, anFFT:+anFFT.value, anSmooth:+anSmooth.value
  }; }
  function setState(s){
    gainEl.value=s.gain; gainEl.oninput({target:gainEl});
    rateEl.value=s.rate; rateEl.oninput({target:rateEl});
    distDrive.value=s.distDrive; distDrive.oninput({target:distDrive});
    distTone.value=s.distTone; distTone.oninput({target:distTone});
    bassGain.value=s.bassGain; bassGain.oninput({target:bassGain});

    filterType.value=s.filterType; biquad.type=s.filterType;
    filterFreq.value=s.filterFreq; filterFreq.oninput({target:filterFreq});
    filterQ.value=s.filterQ; filterQ.oninput({target:filterQ});
    filterGain.value=s.filterGain; filterGain.oninput({target:filterGain});
    filterWet.value=s.filterWet; filterWet.oninput({target:filterWet});

    delayTime.value=s.delayTime; delayTime.oninput({target:delayTime});
    delayFb.value=s.delayFb; delayFb.oninput({target:delayFb});
    delayWet.value=s.delayWet; delayWet.oninput({target:delayWet});

    reverbWet.value=s.reverbWet; reverbWet.oninput({target:reverbWet});
    pitchShift.value=s.pitch; pitchShift.oninput({target:pitchShift});

    compThresh.value=s.compThresh; compThresh.oninput({target:compThresh});
    compKnee.value=s.compKnee; compKnee.oninput({target:compKnee});
    compRatio.value=s.compRatio; compRatio.oninput({target:compRatio});
    compAttack.value=s.compAttack; compAttack.oninput({target:compAttack});
    compRelease.value=s.compRelease; compRelease.oninput({target:compRelease});
    compMakeup.value=s.compMakeup; compMakeup.oninput({target:compMakeup});

    tremOn.checked=!!s.tremOn; tremRate.value=s.tremRate; tremDepth.value=s.tremDepth; applyTremoloParams();

    wideWidth.value=s.wideWidth; wideHaas.value=s.wideHaas; applyWidthParams();
    crushBits.value=s.crushBits; crushMix.value=s.crushMix; applyCrushParams();

    if(s.anFFT){ anFFT.value=String(s.anFFT); }
    if(s.anSmooth!=null){ anSmooth.value=String(s.anSmooth); anSmoothVal.textContent=parseFloat(s.anSmooth).toFixed(2); }
    if(s.anTap){ anTap.value=s.anTap; }
    applyAnalyzerParams();
  }
  function loadPresets(){
    presetList.innerHTML="";
    const all=JSON.parse(localStorage.getItem("miniAudioPresets")||"{}");
    for(const k in all){
      const opt=document.createElement("option"); opt.value=k; opt.textContent=k;
      presetList.appendChild(opt);
    }
  }
  savePreset.onclick=()=>{
    const name=presetName.value.trim();
    if(!name) return alert("Enter a name for the preset.");
    const all=JSON.parse(localStorage.getItem("miniAudioPresets")||"{}");
    all[name]=getState();
    localStorage.setItem("miniAudioPresets",JSON.stringify(all));
    loadPresets();
  };
  loadPreset.onclick=()=>{
    const name=presetList.value; if(!name) return;
    const all=JSON.parse(localStorage.getItem("miniAudioPresets")||"{}");
    if(all[name]) setState(all[name]);
  };
  deletePreset.onclick=()=>{
    const name=presetList.value; if(!name) return;
    const all=JSON.parse(localStorage.getItem("miniAudioPresets")||"{}");
    delete all[name];
    localStorage.setItem("miniAudioPresets",JSON.stringify(all));
    loadPresets();
  };
  loadPresets();

  // WAV encoder
  function encodeWav(audioBuffer){
    const nCh=audioBuffer.numberOfChannels, sr=audioBuffer.sampleRate, len=audioBuffer.length;
    const inter=new Int16Array(len*nCh);
    const tmp=new Float32Array(len);
    for(let ch=0; ch<nCh; ch++){
      audioBuffer.copyFromChannel(tmp, ch, 0);
      for(let i=0, j=ch; i<len; i++, j+=nCh){
        let v=Math.max(-1, Math.min(1, tmp[i]));
        inter[j]=v<0? v*0x8000 : v*0x7FFF;
      }
    }
    const buf=new ArrayBuffer(44 + inter.length*2);
    const dv=new DataView(buf);
    function wStr(o,s){ for(let i=0;i<s.length;i++) dv.setUint8(o+i, s.charCodeAt(i)); }
    wStr(0,"RIFF"); dv.setUint32(4,36+inter.length*2,true); wStr(8,"WAVE");
    wStr(12,"fmt "); dv.setUint32(16,16,true); dv.setUint16(20,1,true);
    dv.setUint16(22,nCh,true); dv.setUint32(24,sr,true);
    dv.setUint32(28,sr*nCh*2,true); dv.setUint16(32,nCh*2,true);
    dv.setUint16(34,16,true); wStr(36,"data"); dv.setUint32(40,inter.length*2,true);
    for(let i=0, off=44; i<inter.length; i++, off+=2) dv.setInt16(off, inter[i], true);
    return new Blob([dv], {type:"audio/wav"});
  }

  /* ===================== Analyzer Drawing ===================== */
  // Hi-DPI canvas sizing
  function fitCanvas(canvas){
    const dpr=window.devicePixelRatio||1;
    const rect=canvas.getBoundingClientRect();
    canvas.width=Math.max(2,Math.floor(rect.width*dpr));
    canvas.height=Math.max(2,Math.floor(rect.height*dpr));
    const g=canvas.getContext("2d");
    g.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    return g;
  }
  let waveCtx=fitCanvas(waveCanvas);
  let fftCtx=fitCanvas(fftCanvas);
  window.addEventListener("resize",()=>{ waveCtx=fitCanvas(waveCanvas); fftCtx=fitCanvas(fftCanvas); });

  // Analyzer params
  function applyAnalyzerParams(){
    const N=parseInt(anFFT.value);
    const s=parseFloat(anSmooth.value);
    analyserPre.fftSize=N; analyserPost.fftSize=N;
    analyserPre.smoothingTimeConstant=s; analyserPost.smoothingTimeConstant=s;
    anSmoothVal.textContent=s.toFixed(2);
  }
  anFFT.onchange=applyAnalyzerParams;
  anSmooth.oninput=applyAnalyzerParams;
  anTap.onchange=applyAnalyzerParams;
  applyAnalyzerParams();

  const waveBuf = new Uint8Array(analyserPost.fftSize);
  const freqBuf = new Uint8Array(analyserPost.frequencyBinCount);

  function drawGrid(g, w, h){
    g.strokeStyle= "rgba(255,255,255,0.07)";
    g.lineWidth=1;
    g.beginPath();
    // horizontal thirds
    g.moveTo(0,h*0.5); g.lineTo(w,h*0.5);
    g.moveTo(0,h*0.25); g.lineTo(w,h*0.25);
    g.moveTo(0,h*0.75); g.lineTo(w,h*0.75);
    // vertical quarters
    for(let i=1;i<4;i++){ const x=w*i/4; g.moveTo(x,0); g.lineTo(x,h); }
    g.stroke();
  }

  function render(){
    const which = (anTap.value==="pre") ? analyserPre : analyserPost;

    // WAVEFORM
    {
      const g=waveCtx, w=waveCanvas.getBoundingClientRect().width, h=waveCanvas.getBoundingClientRect().height;
      g.clearRect(0,0,w,h);
      drawGrid(g,w,h);
      const N=which.fftSize;
      if (waveBuf.length!==N) { waveBuf.set(new Uint8Array(N)); }
      which.getByteTimeDomainData(waveBuf);
      g.lineWidth=2; g.strokeStyle="#6aa1ff";
      g.beginPath();
      for(let i=0;i<N;i++){
        const x=i/N*w;
        const y=(waveBuf[i]/255)*h;
        if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
      }
      g.stroke();
    }

    // SPECTRUM
    {
      const g=fftCtx, w=fftCanvas.getBoundingClientRect().width, h=fftCanvas.getBoundingClientRect().height;
      g.clearRect(0,0,w,h);
      drawGrid(g,w,h);
      const M=which.frequencyBinCount;
      if (freqBuf.length!==M) { /* no-op, created once */ }
      which.getByteFrequencyData(freqBuf);
      g.fillStyle="#6aa1ff";
      const barW = Math.max(1, w / M);
      for(let i=0;i<M;i++){
        const v = freqBuf[i]/255; // 0..1
        const y = v*h;
        g.fillRect(i*barW, h - y, barW*0.95, y);
      }
    }

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
  /* ============================================================ */
})();
</script>
</body>
</html>
